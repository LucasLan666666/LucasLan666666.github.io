# 第二章：主要功能分析与建模

在本章中，我们将对 frp 项目进行建模，并对其主要功能进行详细分析。有必要提前声明，这里所说的
客户端(Client)和服务端(Server)的概念可能会造成一定的混淆。因为在内网主机与公网主机之间通信
的过程中，内网主机是客户端，公网主机是服务端。但是对于用户而言，本质上是内网主机通过公网主机
间接向外部用户提供服务。在之后的章节中，我们将关注于 frp 的实现，因此约定统一的术语：
**将内网主机称为客户端，公网主机称为服务端**。

## 项目概述与建模

frp 工具本身由以下两个部分组成：

- `frps`：**服务端**，部署在具有公网 IP 的节点上，用于接收客户端请求并转发到内网服务。
- `frpc`：**客户端**，部署在内网环境中，用于将内网服务请求发送到服务端。

通过`frpc`和`frps`的紧密配合，就能最终实现内网穿透的功能。在内网穿透服务搭建完成后，任何能
访问互联网的用户都可以通过公网 IP 向内网服务发起请求。以下架构图展示了成功建立 frp 服务后的
工作状态：

![architecture](assets/architecture.png)

可以看到，该模型中包含了三个主体，由上至下分别是：

- `User`：**用户**(可以有多个)，任何能访问互联网的用户。
- `Server`：一个**服务端**，部署了`frps`并且具有公网 IP ，用于接收用户请求并转发到内网服务。
- `Client`：**客户端**(可以有多个)，在局域网环境中并且可以访问互联网，部署了`frpc`，用于将
  内网服务请求发送到服务端。

## 功能分析

### 项目的构建

为了从宏观上把握整个项目的结构，我选择以`Makefile`文件入手，这样可以了解到整个项目的构建过程：

```shell
all: env fmt build

build: frps frpc

...

frps:
    env CGO_ENABLED=0 go build -trimpath -ldflags "$(LDFLAGS)" -tags frps -o bin/frps ./cmd/frps

frpc:
    env CGO_ENABLED=0 go build -trimpath -ldflags "$(LDFLAGS)" -tags frpc -o bin/frpc ./cmd/frpc

...
```

可以看到，`build`规则会分别编译`cmd`目录下的`frps`和`frpc`这两个文件夹下的源文件。编译后的
二进制文件生成在`bin`目录下，这就是最终的可执行文件。

### 整体结构

`cmd`目录下的`frps`和`frpc`目录分别包含了服务端和客户端的入口文件。`cmd`的结构层次如下：

```shell
cmd
├── frpc # 客户端
│   ├── main # 客户端入口
│   └── sub # 客户端子模块
│       ├── admin   # 管理 frpc 的配置和状态
│       ├── nathole # 发现和分类 NAT 特性
│       ├── proxy   # 管理和运行 frpc 的代理和访问者配置
│       ├── root    # 管理和运行 frpc 客户端，包括加载配置、启动服务和处理终止信号
│       └── verify  # 验证 frpc 客户端的配置文件是否有效
└── frps # 服务端
    ├── main   # 服务端入口
    ├── root   # 管理和运行 frps 服务器，包括加载配置、启动服务和处理终止信号
    └── verify # 验证 frps 服务端的配置文件是否有效
```

这样，我们就可以清晰地看到整个项目的结构。

## 核心功能模块

为了成功实现 frp 项目，仅仅依靠`cmd`目录下的`frps`和`frpc`是远远不够的。实际上，整个项目
的功能模块都在`server`、`client`和`pkg`目录下：

- `server`：包含了服务端`frps`所需要的模块。
- `client`：包含了客户端`frpc`所需要的模块。
- `pkg`：一些通用的模块，如`auth`、`config`、`errors`等。

通过调用这些模块，才能实现 frp 的各项功能。它们的目录结构层次如下：

```shell
.
├── server # 服务端 frps 所需要的模块
│   ├── control       # 管理和控制 frp 服务器中的客户端连接和代理
│   ├── controller    # 集中管理和控制各种资源和功能
│   ├── dashboard_api # 通过 HTTP API 管理和监控 frp 服务器
│   ├── group         # 组的成员和属性
│   ├── metrics       # 服务器的度量指标，帮助监控和分析服务器的性能和状态
│   ├── ports         # 端口的分配和释放
│   ├── proxy         # 不同类型的代理
│   ├── service       # 服务器的各项服务和资源
│   └── visitor       # 访客连接
├── client # 客户端 frpc 所需要的模块
│   ├── admin_api     # 允许通过 HTTP 请求对客户端进行管理和控制
│   ├── connector     # 客户端与服务器之间的连接
│   ├── control       # 客户端的控制逻辑
│   ├── event         # 处理代理的启动和关闭事件
│   ├── health        # 定期检查代理的健康状态，并在状态变化时触发相应的回调函数
│   ├── proxy         # 不同类型的代理
│   ├── service       # 客户端的各项服务和资源
│   └── visitor       # 访客连接
└── pkg # 公共模块
    ├── auth          # 不同类型的身份验证
    ├── config        # 配置文件的解析
    ├── errors        # 标识和处理特定的错误情况
    ├── metrics       # 度量指标，帮助监控和分析 frp 的性能和状态
    ├── msg           # 消息传输和处理逻辑
    ├── nathole       # 实现 NAT 穿透(NAT hole punching)功能
    ├── plugin        # 扩展 frp 的插件
    ├── proto         # 处理数据包的转发和管理(目前只有 UDP)
    ├── sdk           # 允许通过 HTTP 请求管理和控制 frp 的行为
    ├── ssh           # SSH 隧道连接
    ├── transport     # 实现传输层安全(TLS)和消息传输功能
    ├── util          # 一些通用的工具函数
    └── virtual       # 虚拟客户端，模拟真实的客户端连接行为
```

利用`tree`工具查看该树状图，我们可以清晰了解整个项目的功能模块划分。这符合面向对象设计的思想——
**高内聚、低耦合**，通过模块化的设计，整个项目的功能更加清晰，易于维护。
